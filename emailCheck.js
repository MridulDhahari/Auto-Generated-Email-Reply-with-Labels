const {google} = require("googleapis");
require('dotenv').config();

const CLIENT_ID = process.env.client_id;
const CLIENT_SECRET = process.env.client_secret;
const REDIRECT_URI = process.env.redirect_uris;
const REFRESH_TOKEN = process.env.refresh_token;


const oAuth2Client = new google.auth.OAuth2(
    CLIENT_ID,
    CLIENT_SECRET,
    REDIRECT_URI
);
oAuth2Client.setCredentials({refresh_token: REFRESH_TOKEN});

const repliedUsers = new Set();

async function checkEmailsAndSendReplies(){
    try{
        const gmail = google.gmail({version:"v1",auth:oAuth2Client});
        // Get all the messages of the Authenticated user which are for the Authenticated User and are Unread.
        const res = await gmail.users.messages.list({
            userId:"me",
            q: "is:unread",
        });
        const messages = res.data.messages;
        //Check if there are any Unread messages
        if(messages && messages.length >0){
            for(const message of messages){
                
                // For every message get the Sender , messageId, To and Subject.
                const email = await gmail.users.messages.get({
                    userId: "me",
                    id: message.id
                })
                // Extracting From,To and Subject from the Email
                const from = email.data.payload.headers.find(
                    (header) => header.name === "From"
                );
                const toHeader = email.data.payload.headers.find(
                    (header) => header.name === "To"
                )
                const Subject = email.data.payload.headers.find(
                    (header) => header.name === "Subject"
                )
                const From = from.value;
                const toEmail = toHeader.value;
                const subject = Subject.value;
                console.log("Email come from : ",From);
                console.log("Email to :",toEmail);
                console.log("subject :",subject);

                //check if the sender has already been replied to
                if(repliedUsers.has(From)){
                    console.log(`${From} has already been replied`);
                    continue;
                }

                //check if the sender has no prior Threads with this message
                //check if the email has any replies
                const thread = await gmail.users.threads.get({
                    userId : "me",
                    id : message.threadId,
                })

                //If after slice(1) operation on the thread , the size is 0 . This means there were no threads to this message before
                // Hence we have to reply to this message
                const replies = thread.data.messages.slice(1);
                if(replies.length===0){
                    //Reply to the mail
                    await gmail.users.messages.send({
                        userId : "me",
                        requestBody:{
                            raw: await createReplyRaw(toEmail,From,subject),
                        },
                        
                    });
                    const labelName = "onVacation";
                    //Adding Label to the message
                    await gmail.users.messages.modify({
                        userId : "me",
                        id : message.id,
                        requestBody:{
                            addLabelIds: [await createLabelIfNeeded(labelName)],
                        }
                    });
                    console.log("Sent reply to email",From);
                    //Adding the sender to the set , so that we wont reply to this sender again
                    repliedUsers.add(From);
                }
            }
            

        }
    }catch(error){
        console.log("Error occured: ",error);
    }
}

async function createReplyRaw(from,to,subject){
    //Write the autogenerated Mail 
    const emailContent = `From: ${from}\nTo: ${to}\nSubject: ${subject}\n\nThank you for your message, this is an auto generated message`;
    const base64EncodedEmail = Buffer.from(emailContent)
       .toString("base64")
       .replace(/\+/g,"-")
       .replace(/\//g,"_");
    return base64EncodedEmail;
}

async function createLabelIfNeeded(labelName){
    const gmail = google.gmail({version:"v1", auth:oAuth2Client});
    //check if label already exist
    const res = await gmail.users.labels.list({userId: "me"});
    const labels = res.data.labels;
    const existingLabel = labels.find((label)=> label.name===labelName);
    if(existingLabel){
        //If already exists then send the labelID;
        return existingLabel.id;
    }
    // Else create a new Label with the given Name and return its LabelId.
    const newLabel = await gmail.users.labels.create({
        userId: "me",
        requestBody: {
            name: labelName,
            labelListVisibility: "labelShow",
            messageListVisibility: "show",
        },
    });
    return newLabel.data.id;
}

function getRandomInterval(min,max){
    return Math.floor(Math.random()*(max - min + 1) + min);
}
function startEmailChecking(){
    //calls the checkEmailsAndSendReplies after some set intervals received form the getRandomInterval function
    setInterval(checkEmailsAndSendReplies,getRandomInterval(45,120)*1000);
};

module.exports= {startEmailChecking};